<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tokyo Property Shortlist</title>
  <style>
    :root {
      --primary: #0066cc;
      --primary-dark: #004c99;
      --success: #2a9d8f;
      --warning: #f4a261;
      --muted: #6c757d;
      --bg: #f8f9fa;
      --card-bg: #ffffff;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 24px;
      background: var(--bg);
      color: #333;
      line-height: 1.5;
    }

    h1 {
      color: #222;
      font-size: 28px;
      margin-bottom: 8px;
    }

    .subtitle {
      color: var(--muted);
      margin-bottom: 24px;
    }


    .property {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .property:hover {
      box-shadow: 0 4px 16px rgba(0,0,0,0.12);
    }

    .property-header {
      display: grid;
      grid-template-columns: 48px 1fr auto;
      align-items: end;
      column-gap: 12px;
      margin-bottom: 12px;
    }

    .rank {
      font-size: 20px;
      font-weight: 700;
      color: var(--muted);
      text-align: right;
      flex-shrink: 0;
      align-self: start;
    }

    .property h2 {
      margin: 0;
      font-size: 18px;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .title-row {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }
    .title-row a {
      min-width: 0;
    }

    .property h2 a {
      text-decoration: none;
      color: var(--primary);
    }

    .property h2 a:hover {
      color: var(--primary-dark);
      text-decoration: underline;
    }
    .jp-subtitle {
      font-size: 13px;
      font-weight: 500;
      color: var(--muted);
      line-height: 1.2;
    }

    .price {
      font-size: 22px;
      font-weight: 700;
      color: var(--success);
      white-space: nowrap;
    }
    .price-wrap {
      display: inline-flex;
      align-items: flex-start;
      gap: 12px;
      justify-self: end;
      align-self: start;
    }
    .price-main {
      display: inline-flex;
      align-items: flex-start;
      gap: 10px;
      flex-wrap: wrap;
      min-width: 0;
    }
    .aggregate-score {
      color: var(--primary);
      font-size: 22px;
      font-weight: 700;
      min-width: 38px;
      text-align: right;
    }
    .star-toggle {
      border: 1px solid #d8dee8;
      background: #fff;
      color: #a0acbb;
      border-radius: 6px;
      width: 28px;
      height: 28px;
      line-height: 1;
      font-size: 16px;
      cursor: pointer;
      padding: 0;
    }
    .star-toggle.active {
      color: #d99a00;
      border-color: #e6c96d;
      background: #fff8dc;
    }

    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      margin: 0 0 18px 0;
      color: #4a5568;
      font-size: 14px;
      align-items: center;
    }
    .filters label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      user-select: none;
    }
    .filters .sort-wrap {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .filters .select-prefix {
      position: relative;
      display: inline-flex;
      align-items: center;
    }
    .filters .select-prefix-label {
      position: absolute;
      left: 10px;
      color: #2f4058;
      font-weight: 600;
      font-size: 13px;
      pointer-events: none;
    }
    .filters .hide-wrap {
      position: relative;
      display: inline-flex;
      align-items: center;
    }
    .filters .hide-toggle {
      border: 1px solid #cfd7e3;
      border-radius: 6px;
      padding: 6px 12px;
      font-size: 13px;
      background: #fff;
      color: #2f4058;
      cursor: pointer;
      font-weight: 600;
      transition: border-color 0.15s ease, box-shadow 0.15s ease;
    }
    .filters .hide-toggle:hover {
      border-color: #b9c7da;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.06);
    }
    .filters .hide-menu {
      position: absolute;
      top: calc(100% + 6px);
      left: 0;
      min-width: 150px;
      background: #fff;
      border: 1px solid #d6deea;
      border-radius: 8px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
      padding: 8px;
      z-index: 20;
      display: none;
    }
    .filters .hide-menu.open {
      display: block;
    }
    .filters .hide-menu label {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 2px;
      cursor: pointer;
      font-size: 13px;
    }
    .filters select {
      border: 1px solid #cfd7e3;
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 13px;
      background: #fff;
      color: #2f4058;
      font-weight: 600;
      transition: border-color 0.15s ease, box-shadow 0.15s ease;
    }
    .filters .select-prefix select {
      padding-left: 56px; /* room for "Sort:" */
    }
    .filters select:hover {
      border-color: #b9c7da;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.06);
    }

    .station-card {
      background: linear-gradient(135deg, #e8f4fd 0%, #f0f7ff 100%);
      border: 1px solid #d0e8f8;
      border-radius: 8px;
      padding: 12px 16px;
      margin: 12px 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
    }

    .station-main {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .station-icon {
      font-size: 20px;
    }

    .station-name {
      font-weight: 600;
      font-size: 16px;
    }

    .station-name a {
      color: var(--primary);
      text-decoration: none;
    }

    .station-name a:hover {
      text-decoration: underline;
    }

    .station-line {
      color: var(--muted);
      font-size: 13px;
      margin-left: 8px;
    }

    .walk-badge, .transit-badge, .total-badge, .transit-pills {
      color: var(--primary);
      font-size: 13px;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 2px;
    }

    .transit-pills {
      /* background: #f0f7ff; */
      padding: 4px 10px;
      border-radius: 16px;
    }

    .station-badges {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .meta {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 12px;
    }

    .tag {
      background: #f0f0f0;
      color: #444;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 13px;
    }
    .tag.notes-toggle {
      border: 1px solid #d6deea;
      cursor: pointer;
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      background: #f8fbff;
      color: #2f4058;
      box-shadow: 0 1px 1px rgba(0, 0, 0, 0.03);
    }
    .tag.notes-toggle[data-expanded="true"] {
      background: #eef5ff;
      color: #1f3555;
      border-color: #c6d4ea;
    }
    .tag.ratings-toggle {
      border: 1px solid #d6deea;
      cursor: pointer;
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      background: #f8fbff;
      color: #2f4058;
      box-shadow: 0 1px 1px rgba(0, 0, 0, 0.03);
    }
    .tag.ratings-toggle[data-expanded="true"] {
      background: #eef5ff;
      color: #1f3555;
      border-color: #c6d4ea;
    }
    .meta-actions {
      margin-left: auto;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .notes-panel {
      background: linear-gradient(135deg, #e8f4fd 0%, #f0f7ff 100%);
      border: 1px solid #d0e8f8;
      border-radius: 8px;
      padding: 12px 16px;
      margin: 12px 0;
    }
    .notes-authors {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 0 0 10px 0;
    }
    .notes-editors {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .notes-editor-head {
      margin: 0 0 6px 0;
    }
    .notes-editor-pill {
      cursor: pointer;
    }
    .notes-author-pill {
      border: 1px solid #d6deea;
      cursor: pointer;
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      background: #f8fbff;
      color: #2f4058;
      box-shadow: 0 1px 1px rgba(0, 0, 0, 0.03);
      border-radius: 4px;
      padding: 4px 10px;
    }
    .notes-author-pill[data-active="true"] {
      background: #eef5ff;
      color: #1f3555;
      border-color: #c6d4ea;
    }
    .notes-author-pill[data-has-content="true"] {
      border-color: #9dc0ea;
    }
    .notes-editor[aria-hidden="true"] {
      display: none;
    }
    .ratings-panel {
      background: linear-gradient(135deg, #eef6ff 0%, #f6faff 100%);
      border: 1px solid #d8e6f7;
      border-radius: 8px;
      padding: 12px 16px;
      margin: 12px 0;
    }
    .ratings-panel.collapsed {
      display: none;
    }
    .ratings-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    .ratings-table th,
    .ratings-table td {
      padding: 6px 4px;
      text-align: left;
      vertical-align: middle;
      border-bottom: 1px solid #e6eef9;
    }
    .ratings-table tr:last-child td {
      border-bottom: 0;
    }
    .ratings-table th {
      color: #42566f;
      font-weight: 600;
    }
    .rating-control {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .rating-range {
      width: 120px;
    }
    .rating-value {
      color: #516277;
      min-width: 34px;
      text-align: right;
    }
    .rating-clear {
      border: 1px solid #c8d6ea;
      background: #fff;
      color: #4a5f7a;
      font-size: 12px;
      font-weight: 700;
      line-height: 1;
      padding: 0;
      margin-left: 0px;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      cursor: pointer;
      /* Keep the layout stable; we toggle visibility instead of display. */
      display: inline-flex;
      visibility: hidden;
      pointer-events: none;
      align-items: center;
      justify-content: center;
      flex: 0 0 auto;
    }
    .rating-clear:hover {
      color: #23364d;
      border-color: #9fb5d1;
      background: #f3f8ff;
    }
    .veto-btn {
      border: 1px solid #d6deea;
      border-radius: 6px;
      padding: 3px 8px;
      font-size: 12px;
      color: #42566f;
      background: #fff;
      cursor: pointer;
    }
    .veto-btn.active {
      border-color: #dc3545;
      color: #fff;
      background: #dc3545;
    }
    .notes-panel.collapsed {
      display: none;
    }
    .notes-input {
      width: 100%;
      min-height: 90px;
      border: 1px solid #c8dff0;
      border-radius: 6px;
      padding: 10px;
      font-size: 14px;
      font-family: inherit;
      resize: vertical;
      box-sizing: border-box;
    }
    .notes-hint {
      color: #5d728a;
      font-size: 13px;
    }
    .tag.transit {
      background: #fff3cd;
      color: #856404;
    }

    .tag.veto-pill {
      background: #dc3545;
      color: #fff;
    }


    .footer {
      text-align: center;
      color: var(--muted);
      margin-top: 40px;
      font-size: 14px;
    }

    @media (max-width: 820px) {
      /* Ratings: switch to stacked layout earlier to avoid overflow. */
      .ratings-panel {
        overflow-x: visible;
      }
      .ratings-table thead {
        display: none;
      }
      .ratings-table,
      .ratings-table tbody,
      .ratings-table tr,
      .ratings-table th,
      .ratings-table td {
        display: block;
        width: 100%;
      }
      .ratings-table tr {
        padding: 8px 0;
      }
      .ratings-table th {
        padding: 6px 0 8px 0;
      }
      .ratings-table td {
        padding: 6px 0;
        border-bottom: 0;
      }
      .rating-control {
        width: 100%;
        justify-content: flex-end;
        gap: 8px;
        flex-wrap: wrap;
      }
      .rating-control::before {
        content: attr(data-metric);
        margin-right: auto;
        color: #42566f;
        font-weight: 600;
        flex: 1 0 110px;
      }
      .rating-range {
        flex: 1 1 180px;
        min-width: 0;
        max-width: none;
        width: auto;
      }
	      .ratings-table tr td:last-child {
	        display: flex;
	        align-items: center;
	        gap: 10px;
	        padding-top: 4px;
	        padding-bottom: 14px;
	      }
	      .ratings-table tr td:last-child::before {
	        content: "";
	        display: none;
	      }
	    }

    @media (max-width: 760px) {
      /* Header: put score/price/star under the title and allow wrapping. */
      .property-header {
        grid-template-columns: 40px 1fr;
        grid-template-areas:
          "rank title"
          "rank price";
        row-gap: 6px;
        align-items: start;
      }
      .property-header .rank {
        grid-area: rank;
        align-self: start;
      }
      .property-header h2 {
        grid-area: title;
      }
      .price-wrap {
        grid-area: price;
        justify-self: start;
        row-gap: 6px;
        column-gap: 10px;
      }
      .price {
        font-size: 20px;
      }
      .aggregate-score {
        font-size: 20px;
        min-width: 0;
        text-align: left;
      }

      /* Meta actions: stack under the meta pills. */
      .meta-actions {
        margin-left: 0;
        flex-basis: 100%;
        width: auto;
        justify-content: flex-start;
        flex-direction: row;
        align-items: center;
        flex-wrap: wrap;
        gap: 8px;
      }
      .meta-actions .tag { justify-content: center; }
    }

    @media (max-width: 600px) {
      body {
        padding: 14px;
      }
      h1 {
        font-size: 24px;
      }
      .property {
        padding: 14px;
      }
      .station-card {
        flex-direction: column;
        align-items: flex-start;
      }
      .notes-author-pill {
        padding: 4px 8px;
        font-size: 12px;
      }
      .notes-input {
        min-height: 80px;
        font-size: 14px;
      }
    }

    /* No special filter breakpoints; the filter bar should wrap naturally. */
  </style>
</head>
<body>
  <h1>ğŸ  Tokyo Property Shortlist</h1>
  <div class="filters">
    <span class="sort-wrap">
      <span class="select-prefix">
        <span class="select-prefix-label">Sort:</span>
        <select id="sort-by" aria-label="Sort">
          <option value="score">Score</option>
          <option value="price">Price</option>
          <option value="sqm">Sqm</option>
          <option value="walk">Walking Distance</option>
          <option value="train">Train Time</option>
          <option value="total">Total Transit Time</option>
        </select>
      </span>
    </span>
    <span class="hide-wrap">
      <button type="button" class="hide-toggle" id="hide-toggle" aria-expanded="false">Hide</button>
      <div class="hide-menu" id="hide-menu">
        <label><input type="checkbox" id="hide-unstarred"> Unstarred</label>
        <label><input type="checkbox" id="hide-sold" checked> Sold</label>
        <label><input type="checkbox" id="hide-vetoed"> Vetoed</label>
      </div>
    </span>
  </div>
  

  <div class="property">
    <div class="property-header">
      <span class="rank">#1</span>
      <h2><a href="properties/yotsuya-high-corp.html">Yotsuya High Corp</a><span class="jp-subtitle">å››è°·ãƒã‚¤ã‚³ãƒ¼ãƒ‘</span></h2>
      <span class="price">Â¥29.98M</span>
    </div>
    <div class="station-card">
      <div class="station-main">
        <span class="station-icon">ğŸš‰</span>
        <span class="station-name">
          <a href="https://www.google.com/maps/search/Yotsuya+Sanchome+Station+Tokyo" target="_blank">Yotsuya Sanchome Station</a>
          <span class="station-line">Tokyo Metro Marunouchi</span>
        </span>
      </div>
      <div class="station-badges">
        <span class="transit-pills">ğŸš¶ 7 min â†’ ğŸš‡ 10 min â†’ 17 min</span>
      </div>
    </div>
    <div class="meta">
      <span class="tag">2DK</span>
      <span class="tag">41.68mÂ²</span>
      <span class="tag ward">Shinjuku-ku</span>
      <span class="tag date">Feb 17</span>
    </div>
  </div>

  <div class="property">
    <div class="property-header">
      <span class="rank">#2</span>
      <h2><a href="properties/nakamachi-corp.html">Nakamachi Corp</a><span class="jp-subtitle">ä»²ç”ºã‚³ãƒ¼ãƒãƒ©ã‚¹</span></h2>
      <span class="price">Â¥26.2M</span>
    </div>
    <div class="station-card">
      <div class="station-main">
        <span class="station-icon">ğŸš‰</span>
        <span class="station-name">
          <a href="https://www.google.com/maps/search/Monzen-Nakacho+Station+Tokyo" target="_blank">Monzen-Nakacho Station</a>
          <span class="station-line">Toei Oedo</span>
        </span>
      </div>
      <div class="station-badges">
        <span class="transit-pills">ğŸš¶ 7 min â†’ ğŸš‡ 11 min â†’ 18 min</span>
      </div>
    </div>
    <div class="meta">
      <span class="tag">1LDK</span>
      <span class="tag">47.21mÂ²</span>
      <span class="tag ward">Koto-ku</span>
      <span class="tag date">Feb 17</span>
      <span class="tag" style="background: #dc3545; color: white;">Sold</span>
    </div>
  </div>

  <div class="property">
    <div class="property-header">
      <span class="rank">#3</span>
      <h2><a href="properties/kasuga-town-home.html">Kasuga Town Home</a><span class="jp-subtitle">æ˜¥æ—¥ã‚¿ã‚¦ãƒ³ãƒ›ãƒ¼ãƒ </span></h2>
      <span class="price">Â¥24.8M</span>
    </div>
    <div class="station-card">
      <div class="station-main">
        <span class="station-icon">ğŸš‰</span>
        <span class="station-name">
          <a href="https://www.google.com/maps/search/Korakuen+Station+Tokyo" target="_blank">Korakuen Station</a>
          <span class="station-line">Tokyo Metro Marunouchi</span>
        </span>
      </div>
      <div class="station-badges">
        <span class="transit-pills">ğŸš¶ 8 min â†’ ğŸš‡ 11 min â†’ 19 min</span>
      </div>
    </div>
    <div class="meta">
      <span class="tag">1LDK</span>
      <span class="tag">50.51mÂ²</span>
      <span class="tag ward">Bunkyo-ku</span>
      <span class="tag date">Feb 17</span>
    </div>
  </div>

  <div class="property">
    <div class="property-header">
      <span class="rank">#4</span>
      <h2><a href="https://realestate.yahoo.co.jp/used/mansion/detail_corp/b0024085388/" target="_blank">Kikugawa Royal Corp</a><span class="jp-subtitle">èŠå·ãƒ­ãƒ¼ã‚¶ãƒ«ã‚³ãƒ¼ãƒ</span></h2>
      <span class="price">Â¥26.8M</span>
    </div>
    <div class="station-card">
      <div class="station-main">
        <span class="station-icon">ğŸš‰</span>
        <span class="station-name">
          <a href="https://www.google.com/maps/search/Kikkawa+Station+Tokyo" target="_blank">Kikkawa Station</a>
          <span class="station-line">Toei Shinjuku</span>
        </span>
      </div>
      <div class="station-badges">
        <span class="transit-pills">ğŸš¶ 4 min â†’ ğŸš‡ 15 min â†’ 19 min</span>
      </div>
    </div>
    <div class="meta">
      <span class="tag">1LDK</span>
      <span class="tag">40.16mÂ²</span>
      <span class="tag ward">Sumida-ku</span>
      <span class="tag date">Feb 18</span>
    </div>
  </div>

  <div class="property">
    <div class="property-header">
      <span class="rank">#5</span>
      <h2><a href="properties/heitsu-otowa.html">Heitsu Otowa</a><span class="jp-subtitle">ãƒã‚¤ãƒ„éŸ³ç¾½</span></h2>
      <span class="price">Â¥29.99M</span>
    </div>
    <div class="station-card">
      <div class="station-main">
        <span class="station-icon">ğŸš‰</span>
        <span class="station-name">
          <a href="https://www.google.com/maps/search/Gokokuji+Station+Tokyo" target="_blank">Gokokuji Station</a>
          <span class="station-line">Tokyo Metro Yurakucho</span>
        </span>
      </div>
      <div class="station-badges">
        <span class="transit-pills">ğŸš¶ 3 min â†’ ğŸš‡ 17 min â†’ 20 min</span>
      </div>
    </div>
    <div class="meta">
      <span class="tag">1LDK</span>
      <span class="tag">37.44mÂ²</span>
      <span class="tag ward">Bunkyo-ku</span>
      <span class="tag date">Feb 17</span>
    </div>
  </div>

  <div class="property">
    <div class="property-header">
      <span class="rank">#6</span>
      <h2><a href="properties/tabata-mansion.html">Tabata Mansion</a><span class="jp-subtitle">ç”°ç«¯ãƒãƒ³ã‚·ãƒ§ãƒ³</span></h2>
      <span class="price">Â¥29.8M</span>
    </div>
    <div class="station-card">
      <div class="station-main">
        <span class="station-icon">ğŸš‰</span>
        <span class="station-name">
          <a href="https://www.google.com/maps/search/Tabata+Station+Tokyo" target="_blank">Tabata Station</a>
          <span class="station-line">JR Yamanote Line</span>
        </span>
      </div>
      <div class="station-badges">
        <span class="transit-pills">ğŸš¶ 5 min â†’ ğŸš‡ 15 min â†’ 20 min</span>
      </div>
    </div>
    <div class="meta">
      <span class="tag">2LDK</span>
      <span class="tag">45.76mÂ²</span>
      <span class="tag ward">Kita-ku</span>
      <span class="tag date">Feb 17</span>
    </div>
  </div>

  <div class="property">
    <div class="property-header">
      <span class="rank">#7</span>
      <h2><a href="properties/oedo-corp.html">Oedo Corp</a><span class="jp-subtitle">å¤§æ±Ÿæˆ¸ã‚³ãƒ¼ãƒ‘</span></h2>
      <span class="price">Â¥29.8M</span>
    </div>
    <div class="station-card">
      <div class="station-main">
        <span class="station-icon">ğŸš‰</span>
        <span class="station-name">
          <a href="https://www.google.com/maps/search/Nakano-Sakaue+Station+Tokyo" target="_blank">Nakano-Sakaue Station</a>
          <span class="station-line">Tokyo Metro Marunouchi</span>
        </span>
      </div>
      <div class="station-badges">
        <span class="transit-pills">ğŸš¶ 1 min â†’ ğŸš‡ 20 min â†’ 21 min</span>
      </div>
    </div>
    <div class="meta">
      <span class="tag">1LDK</span>
      <span class="tag">46.28mÂ²</span>
      <span class="tag ward">Nakano-ku</span>
      <span class="tag date">Feb 17</span>
    </div>
  </div>

  <div class="property">
    <div class="property-header">
      <span class="rank">#8</span>
      <h2><a href="properties/hasegawa-heights.html">Hasegawa Heights</a><span class="jp-subtitle">ãƒã‚»ã‚¬ãƒ¯ãƒã‚¤ãƒ„</span></h2>
      <span class="price">Â¥27.8M</span>
    </div>
    <div class="station-card">
      <div class="station-main">
        <span class="station-icon">ğŸš‰</span>
        <span class="station-name">
          <a href="https://www.google.com/maps/search/Gokokuji+Station+Tokyo" target="_blank">Gokokuji Station</a>
          <span class="station-line">Tokyo Metro Yurakucho</span>
        </span>
      </div>
      <div class="station-badges">
        <span class="transit-pills">ğŸš¶ 4 min â†’ ğŸš‡ 17 min â†’ 21 min</span>
      </div>
    </div>
    <div class="meta">
      <span class="tag">1LDK</span>
      <span class="tag">47.04mÂ²</span>
      <span class="tag ward">Bunkyo-ku</span>
      <span class="tag date">Feb 17</span>
    </div>
  </div>

  <div class="property">
    <div class="property-header">
      <span class="rank">#9</span>
      <h2><a href="properties/palm-house-bunkyo.html">Palm House Bunkyo</a><span class="jp-subtitle">ãƒ‘ãƒ«ãƒ ãƒã‚¦ã‚¹æ–‡äº¬</span></h2>
      <span class="price">Â¥31.8M</span>
    </div>
    <div class="station-card">
      <div class="station-main">
        <span class="station-icon">ğŸš‰</span>
        <span class="station-name">
          <a href="https://www.google.com/maps/search/Edogawabashi+Station+Tokyo" target="_blank">Edogawabashi Station</a>
          <span class="station-line">Tokyo Metro Yurakucho</span>
        </span>
      </div>
      <div class="station-badges">
        <span class="transit-pills">ğŸš¶ 7 min â†’ ğŸš‡ 15 min â†’ 22 min</span>
      </div>
    </div>
    <div class="meta">
      <span class="tag">2DK</span>
      <span class="tag">47.43mÂ²</span>
      <span class="tag ward">Bunkyo-ku</span>
      <span class="tag date">Feb 17</span>
    </div>
  </div>

  <div class="property">
    <div class="property-header">
      <span class="rank">#10</span>
      <h2><a href="properties/palast-nippori.html">Palast Nippori</a><span class="jp-subtitle">ãƒ‘ãƒ©ã‚¹ãƒˆæ—¥æš®é‡Œ</span></h2>
      <span class="price">Â¥26.99M</span>
    </div>
    <div class="station-card">
      <div class="station-main">
        <span class="station-icon">ğŸš‰</span>
        <span class="station-name">
          <a href="https://www.google.com/maps/search/Nippori+Station+Tokyo" target="_blank">Nippori Station</a>
          <span class="station-line">JR Yamanote</span>
        </span>
      </div>
      <div class="station-badges">
        <span class="transit-pills">ğŸš¶ 14 min â†’ ğŸš‡ 12 min â†’ 26 min</span>
      </div>
    </div>
    <div class="meta">
      <span class="tag">1LDK</span>
      <span class="tag">44.7mÂ²</span>
      <span class="tag ward">Arakawa-ku</span>
      <span class="tag date">Feb 17</span>
    </div>
  </div>

  <div class="property">
    <div class="property-header">
      <span class="rank">#11</span>
      <h2><a href="properties/happy-heights-kameido.html">Happy Heights Kameido</a><span class="jp-subtitle">ãƒãƒ”ãƒ¼ãƒã‚¤ãƒ„äº€æˆ¸</span></h2>
      <span class="price">Â¥25.8M</span>
    </div>
    <div class="station-card">
      <div class="station-main">
        <span class="station-icon">ğŸš‰</span>
        <span class="station-name">
          <a href="https://www.google.com/maps/search/Kameido+Station+Tokyo" target="_blank">Kameido Station</a>
          <span class="station-line">JR Sobu</span>
        </span>
      </div>
      <div class="station-badges">
        <span class="transit-pills">ğŸš¶ 3 min â†’ ğŸš‡ 25 min â†’ 28 min</span>
      </div>
    </div>
    <div class="meta">
      <span class="tag">2LDK</span>
      <span class="tag">46.18mÂ²</span>
      <span class="tag ward">Koto-ku</span>
      <span class="tag date">Feb 18</span>
    </div>
  </div>

  <div class="property">
    <div class="property-header">
      <span class="rank">#12</span>
      <h2><a href="properties/ojima-royal-mansion.html">Ojima Royal Mansion</a><span class="jp-subtitle">å¤§å³¶ãƒ­ã‚¤ãƒ¤ãƒ«ãƒãƒ³ã‚·ãƒ§ãƒ³</span></h2>
      <span class="price">Â¥22.8M</span>
    </div>
    <div class="station-card">
      <div class="station-main">
        <span class="station-icon">ğŸš‰</span>
        <span class="station-name">
          <a href="https://www.google.com/maps/search/Ojima+Station+Tokyo" target="_blank">Ojima Station</a>
          <span class="station-line">Toei Shinjuku</span>
        </span>
      </div>
      <div class="station-badges">
        <span class="transit-pills">ğŸš¶ 7 min â†’ ğŸš‡ 24 min â†’ 31 min</span>
      </div>
    </div>
    <div class="meta">
      <span class="tag">1LDK</span>
      <span class="tag">40.01mÂ²</span>
      <span class="tag ward">Koto-ku</span>
      <span class="tag date">Feb 18</span>
    </div>
  </div>

  <div class="property">
    <div class="property-header">
      <span class="rank">#13</span>
      <h2><a href="properties/koken-heights-mejiro.html">Koken Heights Mejiro</a><span class="jp-subtitle">å…‰å»ºãƒã‚¤ãƒ„ç›®ç™½</span></h2>
      <span class="price">Â¥27.5M</span>
    </div>
    <div class="station-card">
      <div class="station-main">
        <span class="station-icon">ğŸš‰</span>
        <span class="station-name">
          <a href="https://www.google.com/maps/search/Shiinamachi+Station+Tokyo" target="_blank">Shiinamachi Station</a>
          <span class="station-line">Seibu Ikebukuro</span>
        </span>
      </div>
      <div class="station-badges">
        <span class="transit-pills">ğŸš¶ 7 min â†’ ğŸš‡ 27 min â†’ 34 min</span>
      </div>
    </div>
    <div class="meta">
      <span class="tag">2DK</span>
      <span class="tag">49.77mÂ²</span>
      <span class="tag ward">Toshima-ku</span>
      <span class="tag date">Feb 18</span>
    </div>
  </div>

  <div class="footer">
    <p>Built with â¤ï¸ by juan</p>
  </div>
  <script src="notes-config.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
	    const NOTES_CONFIG = Object.assign(
	      {
	        supabaseUrl: '',
	        supabaseAnonKey: '',
	        table: 'property_notes',
	        notesByAuthorTable: 'property_notes_by_author',
	        starTable: 'property_flags',
	        ratingTable: 'property_ratings',
	        vetoTable: 'property_vetoes'
	      },
	      window.NOTES_CONFIG || {}
	    );

    // Fail hard if Supabase config is missing
    if (!NOTES_CONFIG.supabaseUrl || !NOTES_CONFIG.supabaseAnonKey) {
      throw new Error('Supabase config missing: supabaseUrl and supabaseAnonKey required in NOTES_CONFIG');
    }

	    const RATERS = ['Joe', 'Max', 'Michelle'];
	    const NOTE_AUTHORS = ['Joe', 'Max', 'Michelle', 'Agent'];
	    const METRICS = ['Neighborhood', 'Transit', 'Layout'];
	    const SORT_OPTIONS = ['score', 'price', 'sqm', 'walk', 'train', 'total'];
	    const UI_PREFS_STORAGE_KEY = 'tokyo_property_shortlist_ui_prefs_v1';

	    const supabaseClient = window.supabase.createClient(NOTES_CONFIG.supabaseUrl, NOTES_CONFIG.supabaseAnonKey);

	    function loadUiPrefs() {
	      const defaults = {
	        sort_key: 'score',
	        hide_unstarred: false,
	        hide_sold: true,
	        hide_vetoed: false
	      };
	      try {
	        const raw = localStorage.getItem(UI_PREFS_STORAGE_KEY);
	        if (!raw) return defaults;
	        const parsed = JSON.parse(raw);
	        const sortKey = typeof parsed.sort_key === 'string' ? parsed.sort_key : defaults.sort_key;
	        return {
	          sort_key: SORT_OPTIONS.includes(sortKey) ? sortKey : defaults.sort_key,
	          hide_unstarred: Boolean(parsed.hide_unstarred),
	          hide_sold: parsed.hide_sold !== false, // default true
	          hide_vetoed: Boolean(parsed.hide_vetoed)
	        };
	      } catch (err) {
	        return defaults;
	      }
	    }

	    function saveUiPrefs(patch) {
	      const next = { ...loadUiPrefs(), ...(patch || {}) };
	      try {
	        localStorage.setItem(UI_PREFS_STORAGE_KEY, JSON.stringify(next));
	      } catch (err) {
	        // Ignore (e.g. disabled storage); UI still works in-memory.
	      }
	      return next;
	    }

    function getPropertySlug(card, idx) {
      const link = card.querySelector('.property-header h2 a');
      const href = link ? (link.getAttribute('href') || '') : '';
      const m = href.match(/properties\/([^/.]+)\.html/i);
      if (m) return m[1];
      const text = (link ? link.textContent : '').toLowerCase();
      if (text.includes('kikugawa')) return 'kikugawa-royal-corp';
      return 'property-' + idx;
    }

    function ensureMetaActions(meta) {
      let actions = meta.querySelector('.meta-actions');
      if (!actions) {
        actions = document.createElement('span');
        actions.className = 'meta-actions';
        meta.appendChild(actions);
      }
      return actions;
    }

    function formatPrices() {
      document.querySelectorAll('.price').forEach(function (el) {
        const m = (el.textContent || '').match(/Â¥\s*([0-9]+(?:\.[0-9]+)?)\s*M/i);
        if (!m) return;
        const value = Number(m[1]);
        if (!Number.isFinite(value)) return;
        el.textContent = 'Â¥' + value.toFixed(1) + 'M';
      });
    }

    function isSoldCard(card) {
      return Array.from(card.querySelectorAll('.meta .tag')).some(function (tag) {
        return (tag.textContent || '').trim().toLowerCase() === 'sold';
      });
    }

    function parseCardMetrics(card) {
      const priceText = (card.querySelector('.price')?.textContent || '').trim();
      const priceMatch = priceText.match(/([0-9]+(?:\.[0-9]+)?)\s*M/i);
      if (priceMatch) card.dataset.price = String(Number(priceMatch[1]));

      const sqmTag = Array.from(card.querySelectorAll('.meta .tag')).find(function (tag) {
        return /mÂ²/i.test(tag.textContent || '');
      });
      const sqmMatch = (sqmTag?.textContent || '').match(/([0-9]+(?:\.[0-9]+)?)\s*mÂ²/i);
      if (sqmMatch) card.dataset.sqm = String(Number(sqmMatch[1]));

      const transitText = card.querySelector('.transit-pills')?.textContent || '';
      const minutes = Array.from(transitText.matchAll(/([0-9]+)\s*min/gi)).map(function (m) {
        return Number(m[1]);
      });
      if (minutes.length >= 3) {
        card.dataset.walk = String(minutes[0]);
        card.dataset.train = String(minutes[1]);
        card.dataset.total = String(minutes[2]);
      }
    }

    function updateRanks() {
      document.querySelectorAll('.property').forEach(function (card, idx) {
        const rankEl = card.querySelector('.rank');
        if (rankEl) rankEl.textContent = '#' + (idx + 1);
      });
    }

    function metricValue(card, key) {
      const raw = card.dataset[key];
      const n = Number(raw);
      return Number.isFinite(n) ? n : null;
    }

    function ratingKey(slug, rater, metric) {
      return slug + '||' + rater + '||' + metric;
    }

    function vetoKey(slug, rater) {
      return slug + '||' + rater;
    }

	    function sortCards() {
	      const sortEl = document.getElementById('sort-by');
	      if (!sortEl) return;
	      const sortKey = sortEl.value || 'score';
	      saveUiPrefs({ sort_key: sortKey });

      const cards = Array.from(document.querySelectorAll('.property'));
      const footer = document.querySelector('.footer');
      if (!footer) return;

      const dir = sortKey === 'price' || sortKey === 'walk' || sortKey === 'train' || sortKey === 'total'
        ? 1
        : -1;
      cards.sort(function (a, b) {
        const av = metricValue(a, sortKey);
        const bv = metricValue(b, sortKey);
        if (av == null && bv == null) return 0;
        if (av == null) return 1;
        if (bv == null) return -1;
        if (av === bv) return 0;
        return av < bv ? -1 * dir : 1 * dir;
      });

      cards.forEach(function (card) {
        footer.parentNode.insertBefore(card, footer);
      });
      updateRanks();
    }

    function updateAggregateForCard(card, slug, ratingsStore) {
      const wrap = card.querySelector('.price-wrap');
      if (!wrap) return;
      const badge = wrap.querySelector('.aggregate-score');
      if (!badge) return;
      const values = [];
      RATERS.forEach(function (rater) {
        METRICS.forEach(function (metric) {
          const v = ratingsStore[ratingKey(slug, rater, metric)];
          if (typeof v === 'number' && Number.isFinite(v)) values.push(v);
        });
      });
      if (!values.length) {
        badge.style.display = 'none';
        badge.textContent = '';
        delete card.dataset.score;
        return;
      }
      const avg = values.reduce(function (a, b) { return a + b; }, 0) / values.length;
      badge.style.display = '';
      badge.textContent = avg.toFixed(1);
      card.dataset.score = avg.toFixed(2);
    }

	    function updateVetoPill(card, slug, vetoStore) {
      const meta = card.querySelector('.meta');
      if (!meta) return;
      const hasVeto = RATERS.some(function (rater) {
        return Boolean(vetoStore[vetoKey(slug, rater)]);
      });
      card.setAttribute('data-vetoed', hasVeto ? 'true' : 'false');
      let pill = meta.querySelector('.veto-pill');
      if (!hasVeto) {
        if (pill) pill.remove();
        return;
      }
      if (!pill) {
        pill = document.createElement('span');
        pill.className = 'tag veto-pill';
        pill.textContent = 'Vetoed';
      }
      const soldTag = Array.from(meta.querySelectorAll('.tag')).find(function (tag) {
        return (tag.textContent || '').trim().toLowerCase() === 'sold';
      });
      const actions = meta.querySelector('.meta-actions');
      if (soldTag && soldTag.parentNode === meta) {
        if (soldTag.nextSibling !== pill) {
          meta.insertBefore(pill, soldTag.nextSibling);
        }
      } else if (actions && actions.parentNode === meta) {
        meta.insertBefore(pill, actions);
      } else {
        meta.appendChild(pill);
      }
	    }

	    function applyFilters() {
	      const hideUnstarredEl = document.getElementById('hide-unstarred');
	      const hideSoldEl = document.getElementById('hide-sold');
      const hideVetoedEl = document.getElementById('hide-vetoed');
      if (!hideUnstarredEl || !hideSoldEl || !hideVetoedEl) return;
      const hideUnstarred = hideUnstarredEl.checked;
      const hideSold = hideSoldEl.checked;
      const hideVetoed = hideVetoedEl.checked;
      document.querySelectorAll('.property').forEach(function (card) {
        const starred = card.getAttribute('data-starred') === 'true';
        const sold = card.getAttribute('data-sold') === 'true';
        const vetoed = card.getAttribute('data-vetoed') === 'true';
	        const show = (!hideUnstarred || starred) && (!hideSold || !sold) && (!hideVetoed || !vetoed);
	        card.style.display = show ? '' : 'none';
	      });
	      saveUiPrefs({ hide_unstarred: hideUnstarred, hide_sold: hideSold, hide_vetoed: hideVetoed });
	    }

	    async function initStarsAndFilters() {
	      formatPrices();
	      const uiPrefs = loadUiPrefs();

      const starredSet = new Set();

      const cards = Array.from(document.querySelectorAll('.property'));
      const slugs = cards.map(function (card, idx) {
        return getPropertySlug(card, idx + 1);
      });

      // Load stars from Supabase
      try {
        const { data } = await supabaseClient
          .from(NOTES_CONFIG.starTable)
          .select('property_slug, starred')
          .in('property_slug', slugs);
        (data || []).forEach(function (row) {
          if (row.starred) starredSet.add(row.property_slug);
          else starredSet.delete(row.property_slug);
        });
      } catch (err) {
        console.error('Failed to load stars from Supabase', err);
      }

      // Load vetoes from Supabase
      const vetoStore = {};
      try {
        const { data } = await supabaseClient
          .from(NOTES_CONFIG.vetoTable)
          .select('property_slug, rater, vetoed')
          .in('property_slug', slugs);
        (data || []).forEach(function (row) {
          vetoStore[vetoKey(row.property_slug, row.rater)] = row.vetoed;
        });
      } catch (err) {
        console.error('Failed to load vetoes from Supabase', err);
      }

      cards.forEach(function (card, idx) {
        const slug = getPropertySlug(card, idx + 1);
        card.setAttribute('data-property-slug', slug);
        card.setAttribute('data-sold', isSoldCard(card) ? 'true' : 'false');
        card.setAttribute('data-vetoed', card.getAttribute('data-vetoed') || 'false');
        parseCardMetrics(card);

        const header = card.querySelector('.property-header');
        const price = card.querySelector('.price');
        if (!header || !price) return;

        let wrap = header.querySelector('.price-wrap');
        if (!wrap) {
          wrap = document.createElement('div');
          wrap.className = 'price-wrap';
          header.insertBefore(wrap, price);
          wrap.appendChild(price);
        }
        let main = wrap.querySelector('.price-main');
        if (!main) {
          main = document.createElement('span');
          main.className = 'price-main';
          // Ensure score+price can wrap independently, while star stays outside.
          wrap.insertBefore(main, price);
          main.appendChild(price);
        }
        let aggregate = wrap.querySelector('.aggregate-score');
        if (!aggregate) {
          aggregate = document.createElement('span');
          aggregate.className = 'aggregate-score';
          aggregate.style.display = 'none';
          main.insertBefore(aggregate, price);
        }

        const star = document.createElement('button');
        star.type = 'button';
        star.className = 'star-toggle';
        star.setAttribute('aria-label', 'Toggle star');
        const active = starredSet.has(slug);
        star.classList.toggle('active', active);
        star.textContent = active ? 'â˜…' : 'â˜†';
        card.setAttribute('data-starred', active ? 'true' : 'false');

        star.addEventListener('click', function () {
          const isActive = star.classList.toggle('active');
          star.textContent = isActive ? 'â˜…' : 'â˜†';
          card.setAttribute('data-starred', isActive ? 'true' : 'false');
          if (isActive) starredSet.add(slug); else starredSet.delete(slug);

          // Save to Supabase
          (async function () {
            try {
              await supabaseClient
                .from(NOTES_CONFIG.starTable)
                .upsert(
                  { property_slug: slug, starred: isActive, updated_at: new Date().toISOString() },
                  { onConflict: 'property_slug' }
                );
            } catch (err) {
              console.error('Star save failed for', slug, err);
            }
          })();

          applyFilters();
        });

        // Place star next to the title (not next to the price).
        const title = card.querySelector('.property-header h2');
        const titleLink = title ? title.querySelector('a') : null;
        let titleRow = title ? title.querySelector('.title-row') : null;
        if (title && titleLink && !titleRow) {
          titleRow = document.createElement('span');
          titleRow.className = 'title-row';
          title.insertBefore(titleRow, titleLink);
          titleRow.appendChild(titleLink);
        }
        if (titleRow) titleRow.appendChild(star);
        else wrap.appendChild(star);
      });

      const hideToggle = document.getElementById('hide-toggle');
      const hideMenu = document.getElementById('hide-menu');
      const hideUnstarredEl = document.getElementById('hide-unstarred');
	      const hideSoldEl = document.getElementById('hide-sold');
	      const hideVetoedEl = document.getElementById('hide-vetoed');
	      const sortEl = document.getElementById('sort-by');
	      if (hideUnstarredEl) hideUnstarredEl.checked = uiPrefs.hide_unstarred;
	      if (hideSoldEl) hideSoldEl.checked = uiPrefs.hide_sold;
	      if (hideVetoedEl) hideVetoedEl.checked = uiPrefs.hide_vetoed;
	      if (sortEl) sortEl.value = uiPrefs.sort_key;
	      if (hideUnstarredEl) hideUnstarredEl.addEventListener('change', applyFilters);
	      if (hideSoldEl) hideSoldEl.addEventListener('change', applyFilters);
	      if (hideVetoedEl) hideVetoedEl.addEventListener('change', applyFilters);
	      if (sortEl) sortEl.addEventListener('change', sortCards);
      if (hideToggle && hideMenu) {
        hideToggle.addEventListener('click', function (e) {
          e.stopPropagation();
          const open = hideMenu.classList.toggle('open');
          hideToggle.setAttribute('aria-expanded', open ? 'true' : 'false');
        });
        hideMenu.addEventListener('click', function (e) {
          e.stopPropagation();
        });
        document.addEventListener('click', function () {
          hideMenu.classList.remove('open');
          hideToggle.setAttribute('aria-expanded', 'false');
        });
      }

      sortCards();
      applyFilters();
    }

    function createNotesUI(card, slug) {
      const meta = card.querySelector('.meta');
      if (!meta) return null;
      const actions = ensureMetaActions(meta);

      const toggle = document.createElement('button');
      toggle.type = 'button';
      toggle.className = 'tag notes-toggle';
      toggle.setAttribute('data-expanded', 'false');
      toggle.textContent = 'Notes';

      actions.appendChild(toggle);

      const panel = document.createElement('div');
      panel.className = 'notes-panel collapsed';
      panel.setAttribute('aria-hidden', 'true');
      let pillsHtml = '';
      let editorsHtml = '';
      NOTE_AUTHORS.forEach(function (author) {
        pillsHtml += '<button type="button" class="notes-author-pill" data-author="' + author + '" data-active="false" data-has-content="false">' + author + '</button>';
        editorsHtml +=
          '<div class="notes-editor" data-author="' + author + '" aria-hidden="true">' +
            '<div class="notes-editor-head">' +
              '<button type="button" class="notes-author-pill notes-editor-pill" data-author="' + author + '" data-active="true">' + author + '</button>' +
            '</div>' +
            '<textarea class="notes-input" data-author="' + author + '" placeholder="Add ' + author + '\'s notes..."></textarea>' +
          '</div>';
      });
      panel.innerHTML =
        '<div class="notes-authors">' + pillsHtml + '</div>' +
        '<div class="notes-editors">' +
          editorsHtml +
        '</div>' +
        '<div class="notes-hint"></div>';
      card.appendChild(panel);

      function setExpanded(expanded) {
        toggle.setAttribute('data-expanded', expanded ? 'true' : 'false');
        toggle.textContent = 'Notes';
        panel.classList.toggle('collapsed', !expanded);
        panel.setAttribute('aria-hidden', expanded ? 'false' : 'true');
      }

      toggle.addEventListener('click', function () {
        setExpanded(toggle.getAttribute('data-expanded') !== 'true');
      });

      return { slug, panel, toggle, setExpanded, card };
    }

    function createRatingsUI(card, slug) {
      const meta = card.querySelector('.meta');
      if (!meta) return null;
      const actions = ensureMetaActions(meta);

      const toggle = document.createElement('button');
      toggle.type = 'button';
      toggle.className = 'tag ratings-toggle';
      toggle.setAttribute('data-expanded', 'false');
      toggle.textContent = 'Ratings';

      const notesToggle = actions.querySelector('.notes-toggle');
      if (notesToggle) actions.insertBefore(toggle, notesToggle);
      else actions.appendChild(toggle);

      const panel = document.createElement('div');
      panel.className = 'ratings-panel collapsed';
      panel.setAttribute('aria-hidden', 'true');

      let html = '<table class="ratings-table"><thead><tr><th></th>';
      METRICS.forEach(function (metric) {
        html += '<th>' + metric + '</th>';
      });
      html += '<th>Veto</th>';
      html += '</tr></thead><tbody>';
      RATERS.forEach(function (rater) {
        html += '<tr><th>' + rater + '</th>';
        METRICS.forEach(function (metric) {
          html += '<td><div class="rating-control" data-rater="' + rater + '" data-metric="' + metric + '">' +
            '<input class="rating-range" type="range" min="0" max="10" step="0.1" value="0">' +
            '<span class="rating-value">â€”</span>' +
            '<button type="button" class="rating-clear" aria-label="Clear rating">Ã—</button>' +
            '</div></td>';
        });
        html += '<td><button type="button" class="veto-btn" data-rater="' + rater + '">Veto</button></td>';
        html += '</tr>';
      });
      html += '</tbody></table>';
      panel.innerHTML = html;
      card.appendChild(panel);

      function setExpanded(expanded) {
        toggle.setAttribute('data-expanded', expanded ? 'true' : 'false');
        panel.classList.toggle('collapsed', !expanded);
        panel.setAttribute('aria-hidden', expanded ? 'false' : 'true');
      }
      toggle.addEventListener('click', function () {
        setExpanded(toggle.getAttribute('data-expanded') !== 'true');
      });

      return { slug, panel, toggle, setExpanded, card };
    }

    async function initRatings() {
      const cards = Array.from(document.querySelectorAll('.property'));
      const ratingsStore = {};
      const vetoStore = {};
      const saveTimers = {};

      const entries = cards
        .map((card, idx) => createRatingsUI(card, getPropertySlug(card, idx + 1)))
        .filter(Boolean);
      const slugs = entries.map(function (e) { return e.slug; });

      function renderControl(control, score) {
        const value = control.querySelector('.rating-value');
        const clear = control.querySelector('.rating-clear');
        if (score == null || !Number.isFinite(score)) {
          value.textContent = 'â€”';
          if (clear) {
            clear.style.visibility = 'hidden';
            clear.style.pointerEvents = 'none';
          }
          return;
        }
        value.textContent = score.toFixed(1);
        if (clear) {
          clear.style.visibility = 'visible';
          clear.style.pointerEvents = 'auto';
        }
      }

      function renderEntry(entry) {
        const controls = Array.from(entry.panel.querySelectorAll('.rating-control'));
        controls.forEach(function (control) {
          const rater = control.getAttribute('data-rater');
          const metric = control.getAttribute('data-metric');
          const range = control.querySelector('.rating-range');
          const key = ratingKey(entry.slug, rater, metric);
          const existing = ratingsStore[key];
          if (typeof existing === 'number' && Number.isFinite(existing)) {
            range.value = String(existing);
            renderControl(control, existing);
          } else {
            renderControl(control, null);
          }
        });
        updateAggregateForCard(entry.card, entry.slug, ratingsStore);

        const vetoButtons = Array.from(entry.panel.querySelectorAll('.veto-btn'));
        vetoButtons.forEach(function (btn) {
          const rater = btn.getAttribute('data-rater');
          const key = vetoKey(entry.slug, rater);
          btn.classList.toggle('active', Boolean(vetoStore[key]));
        });
        updateVetoPill(entry.card, entry.slug, vetoStore);
      }

      // Bind listeners immediately so controls are never inert.
      entries.forEach(function (entry) {
        const controls = Array.from(entry.panel.querySelectorAll('.rating-control'));
        controls.forEach(function (control) {
          const rater = control.getAttribute('data-rater');
          const metric = control.getAttribute('data-metric');
          const range = control.querySelector('.rating-range');
          const clear = control.querySelector('.rating-clear');
          const key = ratingKey(entry.slug, rater, metric);

          const persist = function (score) {
            if (score == null || !Number.isFinite(score)) delete ratingsStore[key];
            else ratingsStore[key] = score;

            (async function () {
              try {
                let error = null;
                if (score == null || !Number.isFinite(score)) {
                  const res = await supabaseClient
                    .from(NOTES_CONFIG.ratingTable)
                    .delete()
                    .eq('property_slug', entry.slug)
                    .eq('rater', rater)
                    .eq('metric', metric);
                  error = res.error;
                } else {
                  const res = await supabaseClient
                    .from(NOTES_CONFIG.ratingTable)
                    .upsert(
                      {
                        property_slug: entry.slug,
                        rater: rater,
                        metric: metric,
                        score: score,
                        updated_at: new Date().toISOString()
                      },
                      { onConflict: 'property_slug,rater,metric' }
                    );
                  error = res.error;
                }
                if (error) throw error;
              } catch (err) {
                console.error('Rating save failed', entry.slug, rater, metric, err);
              }
            })();
          };

          const onChange = function () {
            const score = Number(range.value);
            renderControl(control, score);
            ratingsStore[key] = score;
            updateAggregateForCard(entry.card, entry.slug, ratingsStore);
            if (saveTimers[key]) clearTimeout(saveTimers[key]);
            saveTimers[key] = setTimeout(function () {
              persist(score);
            }, 400);
          };

          range.addEventListener('input', onChange);
          range.addEventListener('change', onChange);

          if (clear) {
            clear.addEventListener('click', function () {
              range.value = '0';
              renderControl(control, null);
              delete ratingsStore[key];
              updateAggregateForCard(entry.card, entry.slug, ratingsStore);
              if (saveTimers[key]) clearTimeout(saveTimers[key]);
              saveTimers[key] = setTimeout(function () {
                persist(null);
              }, 250);
            });
          }
        });

        const vetoButtons = Array.from(entry.panel.querySelectorAll('.veto-btn'));
        vetoButtons.forEach(function (btn) {
          const rater = btn.getAttribute('data-rater');
          const key = vetoKey(entry.slug, rater);
          btn.addEventListener('click', function () {
            const next = !Boolean(vetoStore[key]);
            vetoStore[key] = next;
            btn.classList.toggle('active', next);
            updateVetoPill(entry.card, entry.slug, vetoStore);
            applyFilters();
            (async function () {
              try {
                await supabaseClient
                  .from(NOTES_CONFIG.vetoTable)
                  .upsert(
                    {
                      property_slug: entry.slug,
                      rater: rater,
                      vetoed: next,
                      updated_at: new Date().toISOString()
                    },
                    { onConflict: 'property_slug,rater' }
                  );
              } catch (err) {
                console.error('Veto save failed', entry.slug, rater, err);
              }
            })();
          });
        });

        renderEntry(entry);
      });

      applyFilters();
      if (document.getElementById('sort-by')?.value === 'score') sortCards();

      // Hydrate from Supabase after listeners are live.
      try {
        const { data } = await supabaseClient
          .from(NOTES_CONFIG.ratingTable)
          .select('property_slug, rater, metric, score')
          .in('property_slug', slugs);
        (data || []).forEach(function (row) {
          const score = Number(row.score);
          if (!Number.isFinite(score)) return;
          ratingsStore[ratingKey(row.property_slug, row.rater, row.metric)] = score;
        });
      } catch (err) {
        console.error('Failed to load ratings from Supabase', err);
      }

      try {
        const { data } = await supabaseClient
          .from(NOTES_CONFIG.vetoTable)
          .select('property_slug, rater, vetoed')
          .in('property_slug', slugs);
        (data || []).forEach(function (row) {
          vetoStore[vetoKey(row.property_slug, row.rater)] = row.vetoed;
        });
      } catch (err) {
        console.error('Failed to load vetoes from Supabase', err);
      }

      entries.forEach(renderEntry);
      applyFilters();
      if (document.getElementById('sort-by')?.value === 'score') sortCards();
    }

    async function initNotes() {
      const cards = Array.from(document.querySelectorAll('.property'));
      const entries = cards.map((card, idx) => createNotesUI(card, getPropertySlug(card, idx + 1))).filter(Boolean);
      const slugs = entries.map(e => e.slug);

      // Legacy single-note table. We'll preserve this by mapping old values to Joe.
      const legacyStore = {};
      try {
        const { data } = await supabaseClient
          .from(NOTES_CONFIG.table)
          .select('property_slug, body')
          .in('property_slug', slugs);
        (data || []).forEach(function (row) {
          legacyStore[row.property_slug] = row.body || '';
        });
      } catch (err) {
        console.error('Failed to load legacy notes from Supabase', err);
      }

      const notesStore = {};
      try {
        const { data } = await supabaseClient
          .from(NOTES_CONFIG.notesByAuthorTable)
          .select('property_slug, author, body')
          .in('property_slug', slugs);
        (data || []).forEach(function (row) {
          if (!row.author) return;
          notesStore[row.property_slug + '||' + row.author] = row.body || '';
        });
      } catch (err) {
        console.error('Failed to load per-author notes from Supabase', err);
      }

      // Preserve existing notes by seeding Joe when no Joe note exists yet.
      slugs.forEach(function (slug) {
        const legacy = (legacyStore[slug] || '').trim();
        const joeKey = slug + '||Joe';
        if (legacy && !notesStore[joeKey]) notesStore[joeKey] = legacy;
      });

      entries.forEach(function (entry) {
        const pills = Array.from(entry.panel.querySelectorAll('.notes-author-pill'));
        const topPills = Array.from(entry.panel.querySelectorAll('.notes-author-pill:not(.notes-editor-pill)'));
        const editors = Array.from(entry.panel.querySelectorAll('.notes-editor'));
        const hint = entry.panel.querySelector('.notes-hint');
        const saveTimers = {};

        function notesKey(author) {
          return entry.slug + '||' + author;
        }

        function getEditor(author) {
          return entry.panel.querySelector('.notes-editor[data-author="' + author + '"]');
        }

        function getInput(author) {
          return entry.panel.querySelector('.notes-input[data-author="' + author + '"]');
        }

        function getTopPill(author) {
          return entry.panel.querySelector('.notes-author-pill:not(.notes-editor-pill)[data-author="' + author + '"]');
        }

        function getEditorPill(author) {
          return entry.panel.querySelector('.notes-editor-pill[data-author="' + author + '"]');
        }

        function hasAnyData() {
          return NOTE_AUTHORS.some(function (author) {
            const v = notesStore[notesKey(author)] || '';
            return v.trim().length > 0;
          });
        }

        function isAuthorVisible(author) {
          const editor = getEditor(author);
          return Boolean(editor) && editor.getAttribute('aria-hidden') !== 'true';
        }

        function anyEditorVisible() {
          return NOTE_AUTHORS.some(function (author) {
            return isAuthorVisible(author);
          });
        }

        function setAuthorVisible(author, visible) {
          const editor = getEditor(author);
          const topPill = getTopPill(author);
          const editorPill = getEditorPill(author);
          if (!editor) return;
          editor.setAttribute('aria-hidden', visible ? 'false' : 'true');
          if (topPill) topPill.setAttribute('data-active', visible ? 'true' : 'false');
          if (editorPill) editorPill.setAttribute('data-active', visible ? 'true' : 'false');
          hint.style.display = anyEditorVisible() ? 'none' : '';
          // Reorder only when visibility changes (avoids focus loss while typing).
          reorderEditors();
        }

        function reorderEditors() {
          const container = entry.panel.querySelector('.notes-editors');
          if (!container) return;
          const ordered = NOTE_AUTHORS.slice();
          if (isAuthorVisible('Joe')) {
            const rest = ordered.filter(function (a) { return a !== 'Joe'; });
            rest.unshift('Joe');
            rest.forEach(function (author) {
              const editor = getEditor(author);
              if (editor) container.appendChild(editor);
            });
            return;
          }
          ordered.forEach(function (author) {
            const editor = getEditor(author);
            if (editor) container.appendChild(editor);
          });
        }

        function applyPillLayout() {
          const visibleAuthors = NOTE_AUTHORS.filter(function (author) {
            return isAuthorVisible(author);
          });
          const multiOpen = visibleAuthors.length > 1;
          NOTE_AUTHORS.forEach(function (author) {
            const topPill = getTopPill(author);
            const editor = getEditor(author);
            const editorPill = getEditorPill(author);
            if (topPill) {
              // When multiple editors are open, active authors move their pill to the editor header
              // except Joe, whose pill always stays in the top row.
              const hideOnTop = multiOpen && author !== 'Joe' && visibleAuthors.indexOf(author) !== -1;
              topPill.style.display = hideOnTop ? 'none' : '';
            }
            if (editor) {
              const head = editor.querySelector('.notes-editor-head');
              // Joe's pill stays on the top row even when active; avoid duplicate header pill for Joe.
              if (head) head.style.display = (multiOpen && author !== 'Joe') ? '' : 'none';
            }
            if (editorPill) {
              editorPill.setAttribute('data-active', isAuthorVisible(author) ? 'true' : 'false');
              const v = notesStore[notesKey(author)] || '';
              editorPill.setAttribute('data-has-content', v.trim() ? 'true' : 'false');
            }
          });
        }

        function refreshPills(applyLayout) {
          pills.forEach(function (pill) {
            const author = pill.getAttribute('data-author');
            const v = notesStore[notesKey(author)] || '';
            pill.setAttribute('data-has-content', v.trim() ? 'true' : 'false');
            pill.setAttribute('data-active', isAuthorVisible(author) ? 'true' : 'false');
          });
          if (applyLayout !== false) applyPillLayout();
        }

        const defaultAuthors = NOTE_AUTHORS.filter(function (author) {
          const v = notesStore[notesKey(author)] || '';
          return v.trim().length > 0;
        });

        if (defaultAuthors.length) {
          defaultAuthors.forEach(function (author) {
            setAuthorVisible(author, true);
            const input = getInput(author);
            if (input) input.value = notesStore[notesKey(author)] || '';
          });
          entry.setExpanded(true);
        } else {
          editors.forEach(function (editor) {
            editor.setAttribute('aria-hidden', 'true');
          });
          hint.style.display = '';
          entry.setExpanded(false);
        }
        refreshPills(true);

        async function persistNote(author, value) {
          try {
            const key = notesKey(author);
            if (value) {
              const { error } = await supabaseClient
                .from(NOTES_CONFIG.notesByAuthorTable)
                .upsert(
                  { property_slug: entry.slug, author: author, body: value, updated_at: new Date().toISOString() },
                  { onConflict: 'property_slug,author' }
                );
              if (error) throw error;
              notesStore[key] = value;
            } else {
              const { error } = await supabaseClient
                .from(NOTES_CONFIG.notesByAuthorTable)
                .delete()
                .eq('property_slug', entry.slug)
                .eq('author', author);
              if (error) throw error;
              delete notesStore[key];
            }

            // Keep legacy Joe note in sync for backwards compatibility.
            if (author === 'Joe') {
              if (value) {
                const { error } = await supabaseClient
                  .from(NOTES_CONFIG.table)
                  .upsert(
                    { property_slug: entry.slug, body: value, updated_at: new Date().toISOString() },
                    { onConflict: 'property_slug' }
                  );
                if (error) throw error;
              } else {
                const { error } = await supabaseClient
                  .from(NOTES_CONFIG.table)
                  .delete()
                  .eq('property_slug', entry.slug);
                if (error) throw error;
              }
            }
          } catch (err) {
            console.error('Notes autosave failed for', entry.slug, err);
          }

          refreshPills(false);
          if (hasAnyData() || anyEditorVisible()) entry.setExpanded(true);
        }

        // Top-row pills: show/hide author editors.
        topPills.forEach(function (pill) {
          pill.addEventListener('click', function () {
            const author = pill.getAttribute('data-author');
            const input = getInput(author);
            const nextVisible = !isAuthorVisible(author);
            setAuthorVisible(author, nextVisible);
            if (nextVisible && input) {
              input.value = notesStore[notesKey(author)] || '';
              input.focus();
            }
            refreshPills(true);
            entry.setExpanded(true);
          });
        });

        // In-editor pills: collapse/expand just that author's editor.
        editors.forEach(function (editor) {
          const pill = editor.querySelector('.notes-editor-pill');
          if (!pill) return;
          pill.addEventListener('click', function () {
            const author = pill.getAttribute('data-author');
            const nextVisible = !isAuthorVisible(author);
            setAuthorVisible(author, nextVisible);
            if (!nextVisible) {
              const topPill = getTopPill(author);
              if (topPill) topPill.style.display = '';
            }
            refreshPills(true);
          });
        });

        NOTE_AUTHORS.forEach(function (author) {
          const input = getInput(author);
          if (!input) return;
          input.value = notesStore[notesKey(author)] || '';
          input.addEventListener('input', function () {
            const value = input.value.trim();
            notesStore[notesKey(author)] = value;
            // Don't reorder/hide/show editors while typing; it can steal focus.
            refreshPills(false);
            if (value) entry.setExpanded(true);
            if (saveTimers[author]) clearTimeout(saveTimers[author]);
            saveTimers[author] = setTimeout(function () {
              persistNote(author, value);
            }, 500);
          });
        });
      });
    }

    (async function () {
      try {
        await initStarsAndFilters();
      } catch (err) {
        console.error('initStarsAndFilters failed', err);
      }
      try {
        await initNotes();
      } catch (err) {
        console.error('initNotes failed', err);
      }
      try {
        await initRatings();
      } catch (err) {
        console.error('initRatings failed', err);
      }
    })();
  </script>
</body>
</html>
<!-- Wed Feb 18 16:28:00 +07 2026 -->
